import React, { useRef } from 'react';
import { useCurrentFrame, useVideoConfig, interpolate, spring, staticFile } from 'remotion';
import { useFrame } from '@react-three/fiber';
import { useTexture } from '@react-three/drei';
import * as THREE from 'three';
import { NanoText } from './Typography'; 
import { VisualScenario } from '../types/schema';

interface OutroStageProps {
    scenario: VisualScenario;
    fps: number;
    t_outro_start: number;
}

// Define the design width for which the original coordinates were intended (e.g., 1080p width)
//const DESIGN_WIDTH = 1080; 

export const OutroStage: React.FC<OutroStageProps> = ({ scenario, fps, t_outro_start }) => {
    const frame = useCurrentFrame();
    // 1. Get the actual video dimensions
    const { width } = useVideoConfig(); 
    const { timeline, assets } = scenario;

    // 2. Calculate the global scale factor
    // This factor will be applied to the root <group> to make the scene responsive.
    const globalScaleFactor = width / scenario.meta.resolution.w *1.8;

    // --- PRELOAD TEXTURE ---
    // ... (rest of your component logic remains the same)
    const textureUrl = staticFile(assets.channel_logo_url || assets.thumbnail_url);
    const logoTexture = useTexture(textureUrl);
    
    // Logic: Is the outro active?
    const showOutro = frame >= t_outro_start * fps;
    const logoRef = useRef<THREE.Group>(null!);

    // --- ANIMATION 1: CONTINUOUS LOGO ROTATION (TIMELINE BOUND) ---
    // ... (useFrame logic remains the same)
    useFrame(() => {
        if (logoRef.current && showOutro) {
            // Calculate exactly when rotation should start (0.5s after outro starts)
            const rotationStartFrame = (t_outro_start + 0.5) * fps;
            
            // Calculate how many frames have passed since start
            // Math.max ensures we don't get negative rotation before the start time
            const timeDelta = Math.max(0, frame - rotationStartFrame);

            // Apply rotation based on timeline frame. 
            // 0.05 is the speed factor. Increase/Decrease to change spin speed.
            logoRef.current.rotation.y = timeDelta * 0.05; 
        }
    });

    // --- ANIMATION 2: TEXT SLAM PHYSICS ---
    // ... (slamAnimation function remains the same)
    const slamAnimation = (delay: number) => {
        const startFrame = (t_outro_start + delay) * fps;
        const spr = spring({
            frame: frame - startFrame,
            fps,
            config: { mass: 2, stiffness: 200, damping: 20 },
            from: 0,
            to: 1
        });
        
        return {
            scale: interpolate(spr, [0, 1], [1.5, 1]),
            yOffset: interpolate(spr, [0, 1], [2, 0]),
            visible: frame >= startFrame
        };
    };

    const usp1 = slamAnimation(1); 
    const usp2 = slamAnimation(2);

    if (frame < (t_outro_start - 1) * fps) return null;

    const line1Text = timeline.outro?.line_1 || "SUBSCRIBE";
    const line2Text = timeline.outro?.line_2 || "FOR MORE";

    return (
        // 3. Apply the global scale factor to the root group
        <group 
            position={[0, 0, 1.5]} 
            scale={[
                globalScaleFactor * 0.17, // Original X scale * global factor
                globalScaleFactor * 0.17, // Original Y scale * global factor
                globalScaleFactor * 0.1  // Original Z scale * global factor
            ]}
        >
            
            {/* Soft Ceramic Lighting */}
            <pointLight position={[-2, 4, 4]} intensity={5.0} distance={10} decay={.20} />
            <pointLight position={[2, 4, 4]} intensity={5.0} distance={10} decay={.20} />

            {/* 1. ROTATING CERAMIC BADGE LOGO */}
            {frame >= (t_outro_start + 0.5) * fps && (
                <group ref={logoRef} position={[0, 3.5, 1]} scale={[1.5,1.5,1]}>
                    <mesh>
                        {/* Volumetric Badge */}
                        <boxGeometry args={[2.5, 2.5, 0.08]} />
                        
                        {/* --- CARDBOARD MATERIAL --- */}
                        <meshStandardMaterial 
                            map={logoTexture}
                            transparent={false}
                            side={THREE.DoubleSide} 
                            // Cardboard is non-metallic
                            metalness={0.05} 
                            // Cardboard is rough and matte
                            roughness={0.8} 
                            // Set a base light brown color to simulate the cardboard stock
                            color={new THREE.Color("#A08060")} 
                            
                            // Reduce emissive properties for a duller, non-ceramic look
                            emissive={new THREE.Color("#A08060")}
                            emissiveIntensity={0.00} // Very subtle glow
                            emissiveMap={logoTexture} 
                            envMapIntensity={0.5} // Lower environment map reflection
                            alphaTest={0.5} Â  
                        />
                    </mesh>
                </group>
            )}
            {/* 4. Z-PLANE SEPARATOR (White Rectangle) */}
            {frame >= (t_outro_start + 0.5) * fps && (
                <mesh position={[0, 0, -1]}>
                {/* 10 units wide/tall should ensure it covers the visible area */}
                <boxGeometry args={[100, 100, 0.01]} /> 
                <meshBasicMaterial color={"white"} />
            </mesh>
            )}

            {/* 2. USP TEXT LINE 1 */}
            {usp1.visible && (
                <NanoText
                    text={line1Text}
                    position={[0, -1 + usp1.yOffset, 0.5]}
                    fontSize={0.8}
                    color="black"
                    anchorX="center"
                    anchorY="middle"
                    fontUrl={assets.font_url} 
                />
            )}

            {/* 3. USP TEXT LINE 2 */}
            {usp2.visible && (
                <NanoText
                    text={line2Text}
                    position={[0, -2 + usp2.yOffset, 0.5]}
                    fontSize={0.5}
                    color="#333333" 
                    anchorX="center"
                    anchorY="middle"
                    fontUrl={assets.font_url}
                />
            )}
        </group>
    );
};